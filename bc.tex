%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%                                    %%%
%%% Šablona bakalářské práce na MFF UK %%%
%%%                                    %%%
%%% (c) František Štrupl, 2005         %%%
%%%                                    %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% POZOR: Úprava bakalářské práce je závislá rovněž na volbě jednostranného resp. oboustranného tisku.
%%%        Bližši informace naleznete v dokumentu Úprava bakalářské práce, který se nalézá na adrese:
%%%        http://www.mff.cuni.cz/studium/obecne/bplayout/pok12mo4.pdf

\documentclass[12pt,notitlepage]{report}
%\pagestyle{headings}
\pagestyle{plain}

\frenchspacing % aktivuje použití některých českých typografických pravidel

\usepackage[utf8]{inputenc} % nastavuje použité kódování, uživatelé Windows zamění latin2 za cp1250
\usepackage[czech]{babel}
\usepackage{a4wide} % nastavuje standardní evropský formát stránek A4
%\usepackage{index} % nutno použít v případě tvorby rejstříku balíčkem makeindex
%\usepackage{fancybox} % umožňuje pokročilé rámečkování :-)
\usepackage[pdftex]{graphicx} % nezbytné pro standardní vkládání obrázků do dokumentu
\usepackage{hyperref}
\usepackage{epstopdf}
\usepackage{url}

\usepackage[left=4cm]{geometry} % nastavení dané velikosti okrajů

%\newindex{default}{idx}{ind}{Rejstřík} % zavádí rejstřík v případě použití balíku index

\title{Řízení robota e-Puck v Pythonu}   % tyto dvě položky jsou zde v podstatě formálně, ve skutečnosti nejsou nikde
\author{David Marek} % dále v dokumentu použity

%\date{}

\begin{document}

%\csprimeson % zapne jednoduché psaní českých uvozovek pomocí klasických znaků, ale potom pozor
             % na originální apostrofy, které budou chybně interpretovány!!!

%%% Následuje první, úvodní, strana bakalářské práce. Jednotlivé položky nahraďte dle vlastních
%%% údajů. Změnit podle konkrétní délky jednotlivých položek můžete i zalomení řádků.
\begin{titlepage}
\begin{center}
\ \\

\vspace{15mm}

\large
Univerzita Karlova v Praze\\
Matematicko-fyzikální fakulta\\

\vspace{5mm}

{\Large\bf BAKALÁŘSKÁ PRÁCE}

\vspace{10mm}

%%% Aby vložní loga vše správně fungovalo, je třeba mít soubor logo.eps nahraný v pracovním adresáři,
%%% tj. v adresáři, kde se nachází překládaný zdrojový soubor. Soubor logo.eps je možné získat např.
%%% na adrese: http://www.mff.cuni.cz/fakulta/symboly/logo.eps
\includegraphics[scale=0.3]{logo.eps}

\vspace{15mm}

%\normalsize
{\Large David Marek}\\ % doplňte vaše jméno
\vspace{5mm}
{\Large\bf Řízení robota e-puck v Pythonu}\\ % doplňte název práce
\vspace{5mm}
Kabinet software a výuky informatiky\\ % doplňte název katedry či ústavu
\end{center}
\vspace{15mm}

\large
\noindent Vedoucí bakalářské práce: RNDr. František Mráz, CSc. % doplňte odpovídající údaje
%%% další řádek můžete ve většině případů (tj. pokud údaje uvedené výše nejsou příliš dlouhé) zrušit
\vspace{1mm}

\noindent Studijní program: Obecná Informatika
%\noindent Studijní program: název studijního programu, název studijního % doplňte odpovídající údaje
%%% další řádek můžete ve většině případů (tj. pokud údaje uvedené výše nejsou příliš dlouhé) zrušit
%\hskip20mm oboru (směru),  příp. název studijního plánu

\vspace{20mm}

\begin{center}
2010 % doplňte rok vzniku vaší bakalářské práce
\end{center}

\end{titlepage} % zde končí úvodní strana

\normalsize % nastavení normální velikosti fontu
\setcounter{page}{2} % nastavení číslování stránek
\ \vspace{10mm}

\noindent Na tomto místě mohou být napsána případná poděkování (vedoucímu práce, konzultantovi, tomu, kdo půjčil software, literaturu, poskytl data apod.). % doplňte vlastní text

\vspace{\fill} % nastavuje dynamické umístění následujícího textu do spodní části stránky
\noindent Prohlašuji, že jsem svou bakalářskou práci napsal samostatně a výhradně s použitím citovaných pramenů. Souhlasím se zapůjčováním práce a jejím zveřejňováním.

\bigskip
\noindent V Praze dne \hspace{\fill}David Marek\\ % doplňte patřičné datum, jméno a příjmení

%%%   Výtisk pak na tomto míste nezapomeňte PODEPSAT!
%%%                                         *********

\tableofcontents % vkládá automaticky generovaný obsah dokumentu

\newpage % přechod na novou stránku

%%% Následuje strana s abstrakty. Doplňte vlastní údaje.
\noindent
Název práce: Řízení robota e-puck v Pythonu\\
Autor: David Marek\\
Katedra (ústav): Kabinet software a výuky informatiky\\
Vedoucí bakalářské práce: RNDr. František Mráz, CSc.\\
E-mail vedoucího: mraz@ksvi.mff.cuni.cz\\

\noindent Abstrakt:  V předložené práci studujeme ... Uvede se abstrakt v rozsahu 80 až 200 slov. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Ut sit amet sem. Mauris nec turpis ac sem mollis pretium. Suspendisse neque massa, suscipit id, dictum in, porta at, quam. Nunc suscipit, pede vel elementum pretium, nisl urna sodales velit, sit amet auctor elit quam id tellus. Nullam sollicitudin. Donec hendrerit. Aliquam ac nibh. Vivamus mi. Sed felis. Proin pretium elit in neque. Pellentesque at turpis. Maecenas convallis. Vestibulum id lectus. Fusce dictum augue ut nibh. Etiam non urna nec mi mattis volutpat. Curabitur in tortor at magna nonummy gravida. Mauris turpis quam, volutpat quis, porttitor ut, condimentum sit amet, felis.\\

\noindent Klíčová slova: klíčová slova (3 až 5)

\vspace{10mm}

\noindent
Title: Název bakalářské práce v angličtině\\
Author: Jméno autora\\
Department: Název katedry či ústavu v angličtině\\
Supervisor: Jméno s tituly jako v české verzi, event. pracoviště\\
Supervisor's e-mail address: e-mailová adresa vedoucího\\

\noindent Abstract: In the present work we study ... Uvede se anglický abstrakt v rozsahu 80 až 200 slov. \\

\noindent Keywords: klíčová slova (3 až 5) v angličtině

\newpage

%%% Následuje text bakalářské práce členěný do kapitol, které se číslují, označí názvy a graficky oddělí.
%%% Nedoporučuje se používat víc než dvě úrovně číslování kapitol, viz příklad níže.

\chapter{Úvod}

    \section{Záměr práce}

    \section{Přehled kapitol}

\chapter{Teorie}

    V této části bych rád uvedl všechny základní součásti, na kterých má práce
    stojí a také bych se rád zmínil o způsobech jak se řeší ovládání robota
    jinde. Nejprve je nutné zjistit jaké vlastnosti má robot e-puck, abychom
    pak dále mohli posoudit do jaké míry využíváme jeho předností a také
    zhodnotit využitelnost práce v praxi. Popis e-puck robota je v sekci
    \ref{e-puck robot}. Dále je potřeba zmínit jakými způsoby může probíhat
    komunikace, jaká úskalí přináší oddělení kontrolního programu od hardware a
    jak se dají mírnit rizika z tohoto plynoucí, tím se zabývá sekce
    \ref{sync/async}.

    \section{E-puck robot}
    \label{e-puck robot}
    E-puck je miniaturní robot vytvořený pro výukové účely na akademické
    úrovni. Vytvořen byl v Ecole Polytechnique Fédérale de Laussanne. Celý
    projekt je založen na konceptu otevřeného hardware, což znamená, že všechny
    dokumenty a schémata jsou dostupná pod svobodnou licencí umožňující
    komukoli využívat e-puck robota na maximum a vyvíjet pro něj ať už
    software, anebo např. hardwarové nádstavby.

    E-puck robot byl vytvořen s několika kritérii\cite{bonani}:
    \begin{itemize}
        \item Stolní velikost -- možnost experimentovat s robotem přímo u
        počítače je velmi výhodná pro studenty. Pokud se za optimální velikost
        pracovní plochy považuje 10-ti násobek velikosti robota, tak e-puck se
        svým průměrem 75mm je ideální pro použití na stole.

        \item Široké spektrum použití -- robota je možné použít nejen pro výuku
        robotiky, ale také například pro výuku zpracování obrazu nebo zvuku,
        programování vestavěných systémů, automatizace atd. Toho je docíleno
        velkým spektrem sensorů.

        \item Uživatelská přívětivost -- při vytváření rozhraní by vždy měl být
        kladen důraz na jednoduchost. Rozhraní by mělo být intuitivní a
        důkladně zdokumentované, aby se zrychlil proces učení.

        \item Možnost vzdáleného ovládání -- robot v sobě obsahuje bluetooth
        modul, který se pro něj chová jako sériové zařízení, přes které dokáže
        komunikovat s počítačem.
    \end{itemize}

    Součástí robota je velká škála sensorů a akčních členů. Srdcem robota je
    mikrokontroler s obvodem dsPIC. Skládá se z 16bitového procesoru a jednotky
    pro zpracování signálu. Procesor má frekvenci 64 MHz, 8 kB RAM a 144 kB
    flash paměti. Robot obsahuje následující sensory:

    \begin{itemize}
        \item Infračervené sensory -- po obvodu robota je 8 IR sensorů. Měří
        buď vzdálenost od překážek, anebo intenzitu okolního světla. Jedná se o
        základní sensory využívané pro pohyb mezi překážkami.

        \item Akcelerometr -- 3D akcelerometr slouží k získání vektoru
        zrychlení robota. Může být použit pro spoustu experimentů (měření
        náklonu, zrychlení, detekce nárazu, pádu, \ldots).

        \item 3 mikrofony -- více mikrofonů slouží k triangulaci zdroje zvuku,
        velikost dat získaných z mikrofonů je ovšem na kapacity robota příliš a
        proto je nutné použít jednotku pro zpracování signálu (DSP).

        \item Barevná kamera -- v přední části robota je kamera s rozlišením
        640x480, bohužel kvůli paměťovým omezením robota je možné získat pouze
        část obrazu. I tak je ale možné ji použít pro experimenty s počítačovým
        viděním.
    \end{itemize}

    Samotné sensory by samozřejmě byly bez užitku, kdyby robot neměl žádné
    akční členy. Studenti mohou využít následujících komponent:
    \begin{itemize}
        \item 2 krokové motory -- slouží pro pohyb robota, mají rozlišení 1000
        kroků za jedno otočení kola.

        \item Speaker -- ve spojení s mikrofony může sloužit pro dorozumívání s
        jinými roboty, také jde o výhodný způsob interakce s uživatelem.

        \item 8 LED -- diody jsou rozmístěné po obvodu robota. Slouží jako
        vizuální rozhraní pro uživatele, anebo pro jiného robota.

        \item Zelená dioda uvnitř robota -- hlavním jejím posláním je vypadat
        dobře, ale také může být použita pro interakci s jinými objekty.

        \item Přední dioda u kamery -- tato LED nevytváří rozptýlené světlo,
        ale paprsek, který je možné použít s kamerou pro odhadování vzdálenosti
        k vzdálenějším překážkám.
    \end{itemize}

    Ovládání e-puck robota je možné řešit několika způsoby. V první řadě
    existuje kompatibilní GCC kompilátor, takže je možné psát řídící program,
    který bude vykonáván přímo uvnitř robota, v programovacím jazyku C. Výrobce
    navíc dodává knihovnu s intuitivním rozhraním pro ovládání všech součástí.
    Tento přístup má ovšem několik nevýhod. Cyklus vývoje programu je pomalý,
    kvůli každé změně v programu je třeba spustit kompilaci na počítači, dále
    nahrát program do robota a teprve pak je možné změnu vyzkoušet. Dalším
    problémem je výkon robota, který nemusí stačit pro složitější výpočty.

    Lepším způsobem se tedy zdá využívat program v robotovi pouze pro
    vykonávání příkazů, které jsou naplánovány v počítači. To je přístup,
    kterým se zabývá tato práce. Získáme tím jednu obrovskou výhodu, kterou je
    výpočetní síla stolního počítače, na druhou stranu s ní ovšem musíme
    přijmout i břímě problémů s komunikací.

    \section{Synchronní / asynchronní komunikace}
    \label{sync/async}

    Pojem komunikace ve světě počítačů označuje předávání dat mezi dvěma
    programy nebo zařízeními. Příkladem může být komunikace mezi webovým
    prohlížečem a http serverem při stahování stránky, počítačem a tiskárnou
    při tisku, atd. Průběh komunikace je vždy velmi podobný, jedna strana pošle
    zprávu obsahující požadavek, druhá strana zprávu přijme a zpracuje. Pokud
    ke zpracování potřebuje další informace, pošle odesílateli jako odpověď
    žádost o jejich dodání a tak si zúčastněné strany vymění role a situace se
    opakuje.

    Přenos zprávy ovšem může zabrat netriviálně času a tak je tu problém, co
    bude dělat odesílatel zprávy, zatímco čeká na odpověď. Tady dochází k
    rozdělení na synchronní (nebo také blokující) a asynchronní (neblokující)
    komunikaci. Popisem synchronní komunikace se zabývá sekce \ref{sync},
    popisem asynchronní komunikace sekce \ref{async}. A nakonec je v sekci
    \ref{comm-epuck} popsáno jak byly tyto principy uplatněny v praxi.

    \subsection{Synchronní komunikace}
    \label{sync}

    Při synchronní komunikaci program po odeslání zprávy pozastaví vykonávání
    dalších instrukcí a čeká dokud nedostane odpověď. Tento přístup je velmi
    jednoduchý na implementaci (většinou se jedná o zavolání metody, která
    neskončí, dokud neobdrží zprávu), není problém s nekonzistencí dat (než
    bude program pokračovat v činnosti, obdrží všechny informace).

    Překážkou pro synchronní komunikaci jsou ovšem ztráty zpráv při přenosu.
    Může dojít k chybě při přenosu dat a ke ztrátě odeslané zprávy, anebo
    příchozí odpovědi. Stejně tak se může stát, že adresát zprávy na ni nijak
    neodpověděl. V takovýchto případech lehce dojde k tzv. dead-locku, kdy bude
    odesílatel čekat na zprávu, která nikdy nepřijde a tak nebude moci
    pokračovat v dalších výpočtech.

    \subsection{Asynchronní komunikace}
    \label{async}

    Pokud je po programu požadována interaktivita, anebo komunikace není jeho
    jediným úkolem a musí zvládat například obsluhovat více blokovaných
    spojení, tak synchronní komunikace přestává stačit.

    Asynchronní komunikace řeší některé problémy komunikace synchronní. Po
    odeslání zprávy program pokračuje ve vykonávání instrukcí, nečeká na
    odpověď. Může si ale kdykoli zkontrolovat, zda-li už nepřišla odpověď a pak
    ji teprve načte a zpracuje. Speciálním případem je komunikace řízená
    událostmi (event-driven), kdy je pro zpracování události přijetí zprávy
    určena funkce, která je automaticky spuštěna, bez přímé intervence
    programátora.

    Asynchronní komunikace velmi zjednodušuje vyřešení problémů se ztrátou
    zpráv. Protože program se musí sám podívat jestli nepřišla odpověď, tak si
    také může pamatovat, kdy byla odeslána zpráva a pokud odpověď nedorazí do
    určitého času, tak zprávu prohlásí za ztracenou a může se pokusit ji poslat
    znova.

    I asynchronní komunikace má své problémy. Odpovědi na zprávy nemusí přijít
    ve stejném pořadí, v jakém byly odeslány. Tento problém musí řešit
    například protokol TCP/IP. Řešením je zprávy posílat s pořadovým číslem a
    toto číslo přidat i k odpovědi. Pak je velmi snadné příchozí zprávy seřadit
    podle pořadí, v jakém jsou požadovány.

    \subsection{Komunikace v e-puck knihovně}
    \label{comm-epuck}

    V této práci je uživateli knihovny dána možnost vybrat si mezi komunikací
    synchronní a asynchronní. Synchronní komunikace je určena pro rychlé
    prototypování a zkoušení ovládání robota. Uživatel bude zadávat příkazy a
    dívat se, jak na ně robot reaguje. Tady je výhodná transparentnost
    synchronního přístupu. Naopak pro psaní kontrolních programů je větší důraz
    kladen na spolehlivost. Knihovna zajistí, že příkaz opravdu dojde, v
    nejhorším případě upozorní uživatele na skutečnost, že robot je
    neovladatelný (může se stát třeba pokud mu dochází baterie).

    Máme zde tu výhodu, že e-puck robot vždy pracuje synchronně. Na začátku
    čeká, dokud mu nedojde příkaz, pak se pustí do jeho zpracování. V tu chvíli
    ovšem přestává poslouchat bluetooth spojení a tedy každý další zaslaný
    příkaz bude ztracen. Po zpracování příkazu robot pošle odpověď a opět začne
    čekat na příkazy z počítače. Tedy vždy platí, že robot buď zpracuje zprávy
    v takovém pořadí v jakém byly poslány, anebo případně některé z nich
    vynechá.

    Při asynchronní komunikaci tedy stačí mít frontu příkazů a kontrolovat, že
    je robot postupně vykonává. To je také důvod proč jsou zprávy opatřeny
    kódem příkazu a pořadovým číslem, vždy tak víme na který příkaz právě robot
    odpověděl a který by tedy měl následovat. Díky tomu je možné poslat více
    příkazů, které na první pohled vypadají stejně (např. získání informací ze
    senzorů) a zároveň je odlišit od situace, kdy robot neodpověděl včas a tak
    byla zpráva znovu poslána (bylo totiž předpokládáno, že zprávu nedostal).

    \section{Existující práce}

        \subsection{Webots}

        Webots\cite{webots} je vývojové prostředí a simulátor pro programování robotů.
        Nabízí podporu nejen pro e-puck robota a umožňuje robota programovat v
        několika jazycích (C++, Java, Python).

        Napsané programy je možné spouštět a testovat v simulátoru. To je
        samozřejmě velmi výhodné, pro testování chyb v programu. Ovšem výsledek
        v simulátoru se může od skutečného chování robota velmi lišit. Při
        psaní programů je nutné myslet na to, že sensory v robotovi jsou
        nespolehlivé, jejich hodnoty bývají zašuměné a tak se na ně nedá
        stoprocentně spolehnout. Webots simulátor se snaží virtuální sensory
        přiblížit realitě a tak i hodnoty, které obdrží robot v simulátoru
        neodpovídají přesně simulované realitě.

        Výhodou Webots je tedy kvalitní simulátor, pokud se ovšem podíváme na
        ovládání skutečného robota, tak tady se od mé práce v mnohém neliší.
        Webots umožňuje dva způsoby jak řídit skutečného robota, prvním je
        kompilace programu a nahrání do robota. Ta funguje pouze pokud je
        program napsán v jazyku C.

        Druhé, zajímavější, řešení je použít vzdálené ovládání pomocí
        bluetooth. Zde už mohou být programy napsány v libovolném podporovaném
        jazyce. Do robota je třeba nahrát upravený firmware. Zde ovšem nemohu
        porovnávat, protože Webots šíří firmware pouze v binární podobě, nejsou
        dostupné zdrojové kódy a v dokumentaci jsem nenašel přesnější
        informace, ale všechny funkce jsou volány synchronně.

        Tím se dostáváme k hlavní nevýhodě Webots. Jedná se o komerční projekt,
        dostupná zdarma je pouze testovací časově omezená verze a nejsou
        dostupné zdrojové kódy (právě např. firmware).

        \subsection{Cyberbotics' Robot Curriculum}

        Pokud jsme se bavili o Webots, tak stojí za zmínku také kniha
        Cyberbotics' Robot Curriculum\cite{cyberbotics}. Autorem je Olivier
        Michal, dále byla rozšířena na EPFL, nyní je dostupná na
        Wikibooks\cite{wikibooks}. Kniha je určena všem, kteří mají zájem o
        robotiku. Skládá se ze dvou částí, v první pojednává o teoretických
        základech (umělá inteligence, robotika, e-puck robot), ve druhé už se
        snaží čtenáře naučit jak se ovládají roboti.

        Kniha pro výuku programování robota používá e-puck robota a simulátor
        Webots. Vysvětluje principy, které se při programování robotů
        používají. Postupuje od jednoduchý příkladů jako je pohyb s robotem,
        vyhýbání se překážkám, následování čáry, přes využití všech senzorů
        robota (akcelerometr, kamera) až ke složitějším technikám.

        V kapitole pro pokročilé čtenáře se zabývá odometrií, plánováním cesty,
        rozpoznáváním tvarů, strojovým učením a dalšími metodami vyvíjení
        kontrolního programu (genetické algoritmy, particle swarm optimization,
        \ldots).

        Tato kniha je výborným doplňkem příkladů uvedených v této práci. Může
        být zdrojem zajímavých a podnětných příkladů a experimentů.

        \subsection{Learning Computing With Robots}

        Jedná se o další knihu, která se vztahuje k programování robotů.
        Learning Computing With Robots\cite{learning} ovšem není psána o e-puck
        robotovi, ale o jednoduchém robotovi Scribbler. Kniha se spíše zabývá
        výukou programování v programovacím jazyku Python a robota používá pro
        ukázku zajímavých příkladů.

        Kniha se tedy dá chápat jako úvod pro ty, kdo se chtějí naučit Python,
        aby mohli dále pokračovat v programování ve výuce programování robotů.

        \subsection{Evorobot*}

        \subsection{\ldots}

    \section{Odlišnosti tohoto řešení}

\chapter{Implementace}

    \section{BTcom firmware}

    Robot e-puck v sobě obsahuje programovatelný mikroprocesor. Většina ze
    stávajících řešení se zaměřuje na psaní programu právě pro tento
    mikroprocesor. Ty jsou, co se výpočetního výkonu týče, velmi limitovány.
    Tato práce se však v tomto ohledu liší od ostatních. Programátor píše
    program, který běží na PC a pouze jednotlivé příkazy jsou posílány do
    robota ke zpracování.

    Je tedy potřeba, aby v robotovi byl software, který dokáže přijímat
    příkazy, zpracovávat je a odesílat odpovědi. K tomuto účelu byl upraven
    tvůrci robota poskytovaný firmware BTcom. Jedná se o jednoduchý program,
    který společně se standardní knihovnou dodávanou k e-puck robotovi
    zpřístupňuje všechny senzory a akční členy robota pomocí jednoduchého
    protokolu přes Bluetooth rozhraní.

    \subsection{Příkazy}

    Příkazy je možné posílat v textovém nebo binárním režimu. Textový režim
    slouží k posílání jednoduchých dat jako je ovládání led diod nebo nastavení
    rychlosti motorů. Binární režim slouží k získávání větších dat, jako jsou
    například snímky z kamery.

    Příklad jak může vypadat příkaz poslaný robotovi: {\tt
    Da,100,100\textbackslash r}. Zde se jedná o textový příkaz, první znak
    určuje typ příkazu, písmeno \uv{D} je příkaz pro změnu rychlosti kol. Druhé
    písmeno je tzv. timestamp, jedná se právě o kontrolní znak, který určuje
    pořadí příkazů a odlišuje příkazy stejného typu. Dále následují dvě čísla,
    první určuje rychlost levého kola, druhé rychlost pravého kola. Nakonec je
    znak řádku, který určuje konec příkazu.

    Binární příkazy se také rozlišují písmenem, avšak aby bylo rozpoznání
    zjednodušeno (přesněji řečeno, aby stačilo jedno porovnání), tak kód pro
    binární příkazy je záporný. Firmware přečte kód příkazu jako 8--bitové
    číslo se znaménkem. Pokud je záporné, tak automaticky předpokládá, že vše
    co následuje je binární příkaz. Protože data v příkazu nejsou nijak
    kódována, tak není např. možné předpokládat, že se v příkazu neobjeví číslo
    10, které v ASCII tabulce reprezentuje znak konce řádku. Z toho důvodu jsou
    příkazy ukončeny bytem 0.

    Odpovědi v binárním režimu začínají hlavičkou, která obsahuje identifikaci
    a velikost následující odpovědi. Díky tomu nemusí být nějak speciálně
    ukončovány.

    Hlavní výhodou binárního režimu tedy je úspora dat při přenosu a možnost
    vyhnout se kódování odpovědi a posílat ji jako surová data.

    \subsection{Funkcionalita}

    Firmware funguje velmi přímočaře, jedná se o jednu nekonečnou smyčku, ve
    které načítá příkazy, zavolá příslušné funkce a odešle odpověď.

    Díky tomu, že je program takto prostý, je jednoduché provozovat synchronní
    komunikaci. Program načítá příkazy přesně tak, jak mu přijdou, jeden po
    druhém. Na každý odpoví a teprve pak se přesune na zpracování dalšího
    příkazu. V původní verzi ovšem nastane problém, pokud dojde k poruše
    spojení a nějaký příkaz nedorazí. Program nedokázal problémy tohoto typu
    rozpoznat. Navíc pokud program pracuje v binárním režimu, tak posílal pouze
    data, bez jakéhokoli označení příslušnosti k příkazu, nebo informace o
    povaze dat. Proto bylo provedeno několik úprav, v původním stavu se totiž
    jednalo téměř o neřešitelný problém, rozpoznat ke kterému příkazu data
    přísluší.

    \subsection{Provedené úpravy}

    Provedené úpravy se snaží vyřešit problémy stávajícího řešení a také
    umožňují použití asynchronní komunikace. Ke každému příkazu poslanému
    robotovi se přidává časový otisk, jedná se o 8--bitové číslo, které určuje
    pořadí příkazu v sérii. Ve své odpovědi pak robot uvede jak kód označující
    typ příkazu, na který odpovídá, tak také došlý otisk. Díky tomu je možné
    téměř jednoznačně (otisk se samozřejmě opakuje po určité době znova) svázat
    odpoveď se zaslaným příkazem. Pokud tedy nějaké číslo chybí v posloupnosti
    přijatých odpovědí, je jasné, že tato odpověď nedorazila.

    Odpovědi na binární příkazy nyní vždy obsahují hlavičku, která je pro
    všechny stejná a obsahuje samozřejmě kód příkazu, na který odpovídá, a také
    jeho timestamp, ale hlavně obsahuje i velikost dat, která budou následovat.
    Při binární komunikaci totiž není možné rozpoznat konec přenosu dat. V
    původní verzi firmware se počítalo s tím, že po každém odeslaném příkazu
    bude uživatel čekat na jeho odpověď a tedy bude vědět jakého formátu jsou
    data, která očekává. Pokud se ovšem snažíme o asynchronní komunikaci, tak
    bychom neměli o příchozích datech nic předpokládat.

    Do firmware byly také přidány nové příkazy. Robot obsahuje 3 mikrofony, ale
    není jednoduché nasnímaná data odeslat do PC kvůli jejich velikosti. Pro
    programy, které jsou spouštěny přímo v robotovi, ovšem existuje knihovna
    pro FFT (rychlou Fourierovu transformaci). Ta byla byla přidána do BTcom
    firmwaru a díky ní je možné jedním příkazem zapnout snímání dat z mikrofonu
    a druhým příkazem na nasnímaných datech provést transformaci a odeslat je
    do PC.

    Dalším problémem, se kterým se musí uživatel e-puck robota potýkat, je
    kapacita baterie a nepřítomnost jakéhokoli ukazatele jejího stavu. Tento
    problém byl alespoň částečně vyřešen, do kontrolního programu v robotovi
    bylo přidáno přerušení, které je aktivováno právě tehdy, když napětí na
    baterii již není dostatečné pro bezproblémový provoz. Při vyvolání tohoto
    přerušení jsou zapnuty všechny LED na obvodu robota a tak uživatel dostane
    vizuální upozornění, že je třeba baterii vyměnit.

    \section{Asynchronní komunikace}

    Knihovna umožňuje synchronní i asynchronní komunikaci. Synchronní
    komunikace je dostatečně jednoduchá, tudíž nepotřebuje dlouhé vysvětlování,
    opravdu se děje přesně to, co uživatel očekává. To je také jejím účelem.
    Oproti tomu asynchronní komunikace se snaží co nejvíce usnadnit ovládání
    robota, skrýt některé složitější mechanismy komunikace před uživatelem, a
    proto si zaslouží důkladné představení.

    Základním požadavkem asynchronní komunikace je oddělení zavolání příkazu od
    jeho provedení. Provedení totiž může trvat delší dobu a to se může ukázat v
    některých aplikacích jako klíčový problém. Příkazy tedy nečekají na
    odpověď, ovšem jak se pak uživatel dostane k odpovědi? Zavolání příkazu
    nemůže vrátit odpověď, ale na druhou stranu může vrátit uživateli odkaz na
    potenciální odpověď. Toho se pak může dotázat, zda-li odpověď přišla a
    nakonec ji také i získat. Pro vysvětlení jak tento odkaz funguje bude
    potřeba osvětlit vnitřnosti asynchronní komunikace.

    Asynchronní komunikace už od připojení robota probíhá v samostatném vláknu,
    které je nezávislé od vlákna, ve kterém běží program uživatele. Toto
    komunikační vlákno zastává tři funkce:

    \begin{enumerate}
        \item Odesílání příkazů
        \item Zpracování příchozí komunikace
        \item Kontrola chyb
    \end{enumerate}

    Příchozí komunikace je získávána pomocí sériového připojení vytvořeného
    knihovnou pySerial. Připojení podporuje standardní metody pro práci se
    sockety a je tedy možné používat funkci select operačního systému, která
    dokáže kontrolovat více připojení a oznámit přijetí dat na libovolném z
    nich. První připojení, které je kontrolováno tedy je sériové připojení s
    robotem. Další spojení slouží k získávání nových příkazů.

    \subsection{Odeslání příkazu}

    Při odesílání příkazů se vlastně jedná o přenesení informace v reálném čase
    z jednoho vlákna do druhého. Příkaz je zavolán ve vláknu s uživatelským
    programem, ovšem samotná zpráva robotovi musí být odeslána z vlákna
    asynchronní komunikace. V opačném případě by uživatelský program byl
    zpomalen přenosem k robotovi, navíc asynchronní vlákno má větší přehled o
    spojení s robotem a tedy např. nedojde ke kolizi mezi posíláním a
    přijímáním dat.

    V uživatelském vláknu je příkaz zařazen do fronty pro odchozí příkazy,
    asynchronní vlákno je pak následovně informováno o novém příkazu, nakonec
    je vytvořen odkaz na příkaz, který je vrácen uživateli. Žádný z těchto
    příkazů není blokující, tedy odeslání příkazu nestojí uživatele téměř nic.

    Zbytek odeslání příkazu už probíhá v asynchronním vláknu. Funkce select je
    přerušena informací o novém příkazu. Následně je příkaz odebrán z fronty,
    odeslán robotovi a zařazen do fronty odeslaných zpráv. Zde čeká na příchozí
    odpověď. Uživatel stále vlastní odkaz na tento příkaz, i když se přesunul.

    \subsection{Zpracování odpovědi}

    Pokud se robot rozhodne odeslat odpověď na příkaz, tak se to asynchronní
    vlákno dozví díky funkci select, která označí spojení, které je připraveno
    pro čtení. Následuje tedy přečtení a zpracování odpovědi. Nejprve je
    potřeba rozhodnout, zda-li se jedná o binární nebo textovou odpověď. Na to
    stačí přečíst první znak, ten určuje na který příkaz robot odpovídá. Další
    znak určí timestamp, díky němu už je možné jednoznačně najít příkaz ve
    frontě odeslaných, kterému odpověď patří.

    Odpověď pak už je pouze předána příkazu, který si ji uloží. Příkaz je
    následně odebrán z fronty odeslaných příkazů. Pokud si uživatel uložil
    odkaz na tento příkaz, tak stále má možnost získat odpověď. V opačném
    případě už na objekt nic neukazuje a tedy bude smazán.

    \subsection{Časový limit}

    Může se stát, že příkaz k robotovi nedorazí. Tato skutečnost se těžko
    rozpoznává. Robotovi zabírá vykonání příkazu delší dobu, anebo o příkazu
    vůbec neví? Kdy už se má příkaz považovat za ztracený? Pro vyřešení těchto
    problémů slouží časový limit. Pro každý příkaz má robot přidělen časový
    limit v kterém musí odpovědět. Časový limit je vždy dán funkci select,
    která vlákno zablokuje právě na tuto dobu. Následně dojde ke kontrole
    příkazů. Každý příkaz, který už je ve frontě příliš dlouho, je označen za
    ztracený a poslán znova.

    \section{Ovládání robota}

    Pokud je zajištěna komunikace s robotem, tak samotné jeho ovládání už je
    velmi jednoduché. Při vytváření ovladače robota musí uživatel specifikovat,
    zda-li chce komunikaci synchronní anebo asynchronní. Hlavní změna, kterou
    pozná, je v návratové hodnotě příkazů. Při synchronní komunikaci příkazy
    vrací rovnou výsledek, při asynchronní dostane nejprve odkaz na příkaz. Z
    toho důvodu není možné psát programy, které budou fungovat se synchronní i
    asynchronní komunikací.

    Zaslání příkazu je pouhé zavolání funkce a předání správných parametrů.
    Ovladač se sám stará o vytvoření příkazu, přidá k němu timestamp, zakóduje
    parametry a předá k odeslání.

    Stejně tak ovladač zpracovává příchozí odpovědi, než vydá uživateli
    výsledek. U jednoduchých příkazů, jako je třeba nastavení rychlosti motorů,
    jde pouze o získání dvou čísel z řetězce. U složitějších příkazů už se může
    jednat o netriviální činnost, například při získání fotky je potřeba
    převést fotku z formátu, který používá robot, do formátu standardní
    knihovny pythonu.

\chapter{Uživatelská dokumentace}

    \section{Připojení robota}

    \subsection{Příprava}

    E-puck robot s počítačem komunikuje pomocí bluetooth. Pro připojení robota
    k počítači na operačním systému Linux je třeba mít nainstalovánu podporu
    pro bluetooth. Většinou jsou to balíčky {\tt bluez-firmware} a {\tt
    bluez-utils}, dále je potřeba mít software pro správu pin ({\tt bluez-pin,
    bluez-gnome, bluetooth-applet, \ldots}).

    Nejprve je potřeba zjistit adresu robota. Lze využít utilitu {\tt hcitool}:

    \begin{verbatim}
    $ hcitool scan
    \end{verbatim}

    Adresa robota se použije při nastavení virtuálního sériového portu v souboru {\tt /etc/bluetooth/rfcomm.conf}:

    \begin{verbatim}
    rfcomm0 {
        bind yes;
        device 08:00:17:2C:E0:88; # Adresa zařízení
        channel 1;
        comment "e-puck_0006";    # Vlastní komentář
    }
    \end{verbatim}

    \subsection{Přípojení}
    Následuje již jen vlastní připojení, při kterém se systém může zeptat na
    pin robota. Ten je napsán na robotovi (čtyřmístné číslo na horní straně
    robota).

    \begin{verbatim}
    $ rfcomm bind rfcomm0
    $ rfcomm connect rfcomm0
    \end{verbatim}

    Po těchto příkazech by už mělo být vytvořené spojení s robotem a je možné
    mu začít posílat příkazy pomocí knihovny.

    \subsection{Přehled možných chyb}
    Při připojení mohly nastat chyby, nejčastější jsou tyto:
    \begin{itemize}
    \item{{\em Can't connect RFCOMM socket: Connection refused} -- Nejspíše neběží žádná aplikace, která by se na heslo zeptala. Je třeba spustit např. bluetooth-applet.}
    \item{{\em Can't create RFCOMM TTY: Address already in use} -- Možná příčína je už připojené zařízení. Buď už běží rfcomm, anebo si
        někdo robota přivlastnil. Pro nový pokus o připojení stačí:
            \begin{verbatim}
    $ rfcomm release rfcomm0
    $ rfcomm connect rfcomm0
            \end{verbatim}
    }
    \end{itemize}

    \subsection{Vytvoření připojení v pythonu}

    Pro ovládání robota slouží modul {\tt epuck.controller} a objekt {\tt Controller}. Vytvoření připojení je velmi jednoduché:
    \begin{verbatim}
    from epuck.controller import Controller

    controller = Controller("/dev/rfcomm0")
    \end{verbatim}
    První parametr určuje cestu k vytvořenému portu (zde {\tt /dev/rfcomm0}).
    Je možné také určit, zda-li má komunikace probíhat synchronně (v základu),
    anebo asynchronně. Pak je potřeba zadat ještě argument: {\tt
    asynchronous=True}.

    Další komunikace s robotem pak probíhá přes instanci {\tt controller}.

    \section{Posílání příkazů}

    \section{Přehled příkazů}

\chapter{Příklady kontrolních programů}

\chapter{Závěr}

    \section{Zhodnocení práce}

    \section{Benchmark knihovny}


%%% Seznam literatury
%%%
%%% Literatura se řadí abecedně. Úvádí se pouze literatura, na kterou se v textu odkazuje.
%%% Při odkazu na knihu se vždy uvádějí čísla stránek.

\bibliographystyle{czechiso}
\bibliography{literatura}

\end{document}
