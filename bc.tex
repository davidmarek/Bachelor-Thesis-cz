%{{{ Nastaveni
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%                                    %%%
%%% Šablona bakalářské práce na MFF UK %%%
%%%                                    %%%
%%% (c) František Štrupl, 2005         %%%
%%%                                    %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% POZOR: Úprava bakalářské práce je závislá rovněž na volbě jednostranného resp. oboustranného tisku.
%%%        Bližši informace naleznete v dokumentu Úprava bakalářské práce, který se nalézá na adrese:
%%%        http://www.mff.cuni.cz/studium/obecne/bplayout/pok12mo4.pdf

\documentclass[12pt,notitlepage]{report}
%\pagestyle{headings}
\pagestyle{plain}

\frenchspacing % aktivuje použití některých českých typografických pravidel

\usepackage[utf8]{inputenc} % nastavuje použité kódování, uživatelé Windows zamění latin2 za cp1250
\usepackage[czech]{babel}
\usepackage{a4wide} % nastavuje standardní evropský formát stránek A4
%\usepackage{index} % nutno použít v případě tvorby rejstříku balíčkem makeindex
%\usepackage{fancybox} % umožňuje pokročilé rámečkování :-)
\usepackage[pdftex]{graphicx} % nezbytné pro standardní vkládání obrázků do dokumentu
\usepackage{hyperref}
\usepackage{epstopdf}
\usepackage{url}
\usepackage{minted}

\usepackage[left=4cm]{geometry} % nastavení dané velikosti okrajů

\renewcommand\listingscaption{Zdrojový kód}
\newminted[pyc]{python}{linenos=true, frame=lines}


%\newindex{default}{idx}{ind}{Rejstřík} % zavádí rejstřík v případě použití balíku index

\title{Řízení robota e-Puck v Pythonu}   % tyto dvě položky jsou zde v podstatě formálně, ve skutečnosti nejsou nikde
\author{David Marek} % dále v dokumentu použity

%\date{}

%}}}
\begin{document}
%{{{ Titulka a dalsi stranky pred textem
%\csprimeson % zapne jednoduché psaní českých uvozovek pomocí klasických znaků, ale potom pozor
             % na originální apostrofy, které budou chybně interpretovány!!!

%%% Následuje první, úvodní, strana bakalářské práce. Jednotlivé položky nahraďte dle vlastních
%%% údajů. Změnit podle konkrétní délky jednotlivých položek můžete i zalomení řádků.
\begin{titlepage}
\begin{center}
\ \\

\vspace{15mm}

\large
Univerzita Karlova v Praze\\
Matematicko-fyzikální fakulta\\

\vspace{5mm}

{\Large\bf BAKALÁŘSKÁ PRÁCE}

\vspace{10mm}

%%% Aby vložní loga vše správně fungovalo, je třeba mít soubor logo.eps nahraný v pracovním adresáři,
%%% tj. v adresáři, kde se nachází překládaný zdrojový soubor. Soubor logo.eps je možné získat např.
%%% na adrese: http://www.mff.cuni.cz/fakulta/symboly/logo.eps
\includegraphics[scale=0.3]{logo.eps}

\vspace{15mm}

%\normalsize
{\Large David Marek}\\ % doplňte vaše jméno
\vspace{5mm}
{\Large\bf Řízení robota e-puck v Pythonu}\\ % doplňte název práce
\vspace{5mm}
Kabinet software a výuky informatiky\\ % doplňte název katedry či ústavu
\end{center}
\vspace{15mm}

\large
\noindent Vedoucí bakalářské práce: RNDr. František Mráz, CSc. % doplňte odpovídající údaje
%%% další řádek můžete ve většině případů (tj. pokud údaje uvedené výše nejsou příliš dlouhé) zrušit
\vspace{1mm}

\noindent Studijní program: Obecná Informatika
%\noindent Studijní program: název studijního programu, název studijního % doplňte odpovídající údaje
%%% další řádek můžete ve většině případů (tj. pokud údaje uvedené výše nejsou příliš dlouhé) zrušit
%\hskip20mm oboru (směru),  příp. název studijního plánu

\vspace{20mm}

\begin{center}
2010 % doplňte rok vzniku vaší bakalářské práce
\end{center}

\end{titlepage} % zde končí úvodní strana

\normalsize % nastavení normální velikosti fontu
\setcounter{page}{2} % nastavení číslování stránek
\ \vspace{10mm}

\noindent Na tomto místě mohou být napsána případná poděkování (vedoucímu práce, konzultantovi, tomu, kdo půjčil software, literaturu, poskytl data apod.). % doplňte vlastní text

\vspace{\fill} % nastavuje dynamické umístění následujícího textu do spodní části stránky
\noindent Prohlašuji, že jsem svou bakalářskou práci napsal samostatně a výhradně s použitím citovaných pramenů. Souhlasím se zapůjčováním práce a jejím zveřejňováním.

\bigskip
\noindent V Praze dne \hspace{\fill}David Marek\\ % doplňte patřičné datum, jméno a příjmení

%%%   Výtisk pak na tomto míste nezapomeňte PODEPSAT!
%%%                                         *********

\tableofcontents % vkládá automaticky generovaný obsah dokumentu

\newpage % přechod na novou stránku

%%% Následuje strana s abstrakty. Doplňte vlastní údaje.
\noindent
Název práce: Řízení robota e-puck v Pythonu\\
Autor: David Marek\\
Katedra (ústav): Kabinet software a výuky informatiky\\
Vedoucí bakalářské práce: RNDr. František Mráz, CSc.\\
E-mail vedoucího: mraz@ksvi.mff.cuni.cz\\

\noindent Abstrakt:  V předložené práci studujeme ... Uvede se abstrakt v rozsahu 80 až 200 slov. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Ut sit amet sem. Mauris nec turpis ac sem mollis pretium. Suspendisse neque massa, suscipit id, dictum in, porta at, quam. Nunc suscipit, pede vel elementum pretium, nisl urna sodales velit, sit amet auctor elit quam id tellus. Nullam sollicitudin. Donec hendrerit. Aliquam ac nibh. Vivamus mi. Sed felis. Proin pretium elit in neque. Pellentesque at turpis. Maecenas convallis. Vestibulum id lectus. Fusce dictum augue ut nibh. Etiam non urna nec mi mattis volutpat. Curabitur in tortor at magna nonummy gravida. Mauris turpis quam, volutpat quis, porttitor ut, condimentum sit amet, felis.\\

\noindent Klíčová slova: klíčová slova (3 až 5)

\vspace{10mm}

\noindent
Title: Název bakalářské práce v angličtině\\
Author: Jméno autora\\
Department: Název katedry či ústavu v angličtině\\
Supervisor: Jméno s tituly jako v české verzi, event. pracoviště\\
Supervisor's e-mail address: e-mailová adresa vedoucího\\

\noindent Abstract: In the present work we study ... Uvede se anglický abstrakt v rozsahu 80 až 200 slov. \\

\noindent Keywords: klíčová slova (3 až 5) v angličtině

\newpage

%}}}
\chapter{Úvod} %{{{

    \section{Záměr práce}

    \section{Přehled kapitol}

%}}}
\chapter{Teorie} %{{{

    V této části bych rád uvedl všechny základní součásti, na kterých má práce
    stojí a také bych se rád zmínil o způsobech jak se řeší ovládání robota
    jinde. Nejprve je nutné zjistit jaké vlastnosti má robot e-puck, abychom
    pak dále mohli posoudit do jaké míry využíváme jeho předností a také
    zhodnotit využitelnost práce v praxi. Popis e-puck robota je v sekci
    \ref{e-puck robot}. Dále je potřeba zmínit jakými způsoby může probíhat
    komunikace, jaká úskalí přináší oddělení kontrolního programu od hardware a
    jak se dají mírnit rizika z tohoto plynoucí, tím se zabývá sekce
    \ref{sync/async}.

    \section{E-puck robot}
    \label{e-puck robot}
    E-puck je miniaturní robot vytvořený pro výukové účely na akademické
    úrovni. Vytvořen byl v Ecole Polytechnique Fédérale de Laussanne. Celý
    projekt je založen na konceptu otevřeného hardware, což znamená, že všechny
    dokumenty a schémata jsou dostupná pod svobodnou licencí umožňující
    komukoli využívat e-puck robota na maximum a vyvíjet pro něj ať už
    software, anebo např. hardwarové nádstavby.

    E-puck robot byl vytvořen s několika kritérii \cite{bonani}:
    \begin{itemize}
        \item Stolní velikost -- možnost experimentovat s robotem přímo u
        počítače je velmi výhodná pro studenty. Pokud se za optimální velikost
        pracovní plochy považuje 10-ti násobek velikosti robota, tak e-puck se
        svým průměrem 75mm je ideální pro použití na stole.

        \item Široké spektrum použití -- robota je možné použít nejen pro výuku
        robotiky, ale také například pro výuku zpracování obrazu nebo zvuku,
        programování vestavěných systémů, automatizace atd. Toho je docíleno
        velkým spektrem sensorů.

        \item Uživatelská přívětivost -- při vytváření rozhraní by vždy měl být
        kladen důraz na jednoduchost. Rozhraní by mělo být intuitivní a
        důkladně zdokumentované, aby se zrychlil proces učení.

        \item Možnost vzdáleného ovládání -- robot v sobě obsahuje Bluetooth
        modul, který se pro něj chová jako sériové zařízení, přes které dokáže
        komunikovat s počítačem.
    \end{itemize}

    Součástí robota je velká škála sensorů a akčních členů. Srdcem robota je
    mikrokontroler s obvodem dsPIC. Skládá se z 16bitového procesoru a jednotky
    pro zpracování signálu. Procesor má frekvenci 64 MHz, 8 kB RAM a 144 kB
    flash paměti. Robot obsahuje následující sensory:

    \begin{itemize}
        \item Infračervené sensory -- po obvodu robota je 8 IR sensorů. Měří
        buď vzdálenost od překážek, anebo intenzitu okolního světla. Jedná se o
        základní sensory využívané pro pohyb mezi překážkami.

        \item Akcelerometr -- 3D akcelerometr slouží k získání vektoru
        zrychlení robota. Může být použit pro spoustu experimentů (měření
        náklonu, zrychlení, detekce nárazu, pádu, \ldots).

        \item 3 mikrofony -- více mikrofonů slouží k triangulaci zdroje zvuku,
        velikost dat získaných z mikrofonů je ovšem na kapacity robota příliš a
        proto je nutné použít jednotku pro zpracování signálu (DSP).

        \item Barevná kamera -- v přední části robota je kamera s rozlišením
        640x480, bohužel kvůli paměťovým omezením robota je možné získat pouze
        část obrazu. I tak je ale možné ji použít pro experimenty s počítačovým
        viděním.
    \end{itemize}

    Samotné sensory by samozřejmě byly bez užitku, kdyby robot neměl žádné
    akční členy. Studenti mohou využít následujících komponent:
    \begin{itemize}
        \item 2 krokové motory -- slouží pro pohyb robota, mají rozlišení 1000
        kroků za jedno otočení kola.

        \item Reproduktor -- ve spojení s mikrofony může sloužit pro dorozumívání s
        jinými roboty, také jde o výhodný způsob interakce s uživatelem.

        \item 8 LED -- diody jsou rozmístěné po obvodu robota. Slouží jako
        vizuální rozhraní pro uživatele, anebo pro jiného robota.

        \item Zelená dioda uvnitř robota -- hlavním jejím posláním je zkrášlit
        robota, ale také může být použita pro interakci s jinými objekty.

        \item Přední dioda u kamery -- tato LED nevytváří rozptýlené světlo,
        ale paprsek, který je možné použít s kamerou pro odhadování vzdálenosti
        k vzdálenějším překážkám.
    \end{itemize}

    Ovládání e-puck robota je možné řešit několika způsoby. V první řadě
    existuje kompatibilní GCC kompilátor, takže je možné psát řídící program,
    který bude vykonáván přímo uvnitř robota, v programovacím jazyku C. Výrobce
    navíc dodává knihovnu s intuitivním rozhraním pro ovládání všech součástí.
    Tento přístup má ovšem několik nevýhod. Cyklus vývoje programu je pomalý,
    kvůli každé změně v programu je třeba spustit kompilaci na počítači, dále
    nahrát program do robota a teprve pak je možné změnu vyzkoušet. Dalším
    problémem je výkon robota, který nemusí stačit pro složitější výpočty.

    Lepším způsobem se tedy zdá využívat program v robotovi pouze pro
    vykonávání příkazů, které jsou naplánovány v počítači. To je přístup,
    kterým se zabývá tato práce. Získáme tím jednu obrovskou výhodu, kterou je
    výpočetní síla stolního počítače, na druhou stranu s ní ovšem musíme
    přijmout i břímě problémů s komunikací.

    \section{Synchronní / asynchronní komunikace}
    \label{sync/async}

    Pojem komunikace ve světě počítačů označuje předávání dat mezi dvěma
    programy nebo zařízeními. Příkladem může být komunikace mezi webovým
    prohlížečem a http serverem při stahování stránky, počítačem a tiskárnou
    při tisku, atd. Průběh komunikace je vždy velmi podobný, jedna strana pošle
    zprávu obsahující požadavek, druhá strana zprávu přijme a zpracuje. Pokud
    ke zpracování potřebuje další informace, pošle odesílateli jako odpověď
    žádost o jejich dodání a tak si zúčastněné strany vymění role a situace se
    opakuje.

    Přenos zprávy ovšem může zabrat netriviálně mnoho času a tak je tu problém,
    co bude dělat odesílatel zprávy, zatímco čeká na odpověď. Tady dochází k
    rozdělení na synchronní (nebo také blokující) a asynchronní (neblokující)
    komunikaci. Popisem synchronní komunikace se zabývá sekce \ref{sync},
    popisem asynchronní komunikace sekce \ref{async}. A nakonec je v sekci
    \ref{comm-epuck} popsáno jak byly tyto principy uplatněny v praxi.

    \subsection{Synchronní komunikace}
    \label{sync}

    Při synchronní komunikaci program po odeslání zprávy pozastaví vykonávání
    dalších instrukcí a čeká dokud nedostane odpověď. Tento přístup je velmi
    jednoduchý na implementaci (většinou se jedná o zavolání metody, která
    neskončí, dokud neobdrží zprávu), není problém s nekonzistencí dat (než
    bude program pokračovat v činnosti, obdrží všechny informace).

    Překážkou pro synchronní komunikaci jsou ovšem ztráty zpráv při přenosu.
    Může dojít k chybě při přenosu dat a ke ztrátě odeslané zprávy, anebo
    příchozí odpovědi. Stejně tak se může stát, že adresát zprávy na ni nijak
    neodpověděl. V takovýchto případech lehce dojde k tzv. dead-locku, kdy bude
    odesílatel čekat na zprávu, která nikdy nepřijde a tak nebude moci
    pokračovat v dalších výpočtech.

    Dochází také k mrhání procesorovým časem, čas strávený čekáním na odpověď
    by mohl být smysluplně využit. Typickým příkladem je grafické rozhraní, kde
    je potřeba zaručit interakci a nereagování na akce uživatele je ukazatelem
    špatně napsané aplikace. Ale nemusí jít jen o složité aplikace s grafickým
    rozhraním, čas strávený čekáním lze využít například pro zpracování
    již přijatých dat a díky tomu zvýšit jejich průtok.

    \subsection{Asynchronní komunikace}
    \label{async}

    Pokud je po programu požadována interaktivita, anebo komunikace není jeho
    jediným úkolem a musí zvládat například obsluhovat více blokovaných
    spojení, tak synchronní komunikace přestává stačit.

    Asynchronní komunikace řeší některé problémy komunikace synchronní. Po
    odeslání zprávy program pokračuje ve vykonávání instrukcí, nečeká na
    odpověď. Může si ale kdykoli zkontrolovat, zda-li už nepřišla odpověď a pak
    ji teprve načíst a zpracovat. Speciálním případem je komunikace řízená
    událostmi (event-driven), kdy je pro zpracování události přijetí zprávy
    určena funkce, která je automaticky spuštěna, bez přímé intervence
    programátora.

    Asynchronní komunikace velmi zjednodušuje vyřešení problémů se ztrátou
    zpráv. Protože program se musí sám podívat jestli nepřišla odpověď, tak si
    také může pamatovat, kdy byla odeslána zpráva a pokud odpověď nedorazí do
    určitého času, tak zprávu prohlásí za ztracenou a může se pokusit ji poslat
    znova.

    I asynchronní komunikace má své problémy. Odpovědi na zprávy nemusí přijít
    ve stejném pořadí, v jakém byly odeslány. Tento problém musí řešit
    například protokol TCP/IP. Řešením je zprávy posílat s pořadovým číslem a
    toto číslo přidat i k odpovědi. Pak je velmi snadné příchozí zprávy seřadit
    podle pořadí, v jakém jsou požadovány.

    \subsection{Komunikace v e-puck knihovně}
    \label{comm-epuck}

    V této práci je uživateli knihovny dána možnost vybrat si mezi komunikací
    synchronní a asynchronní. Synchronní komunikace je určena pro rychlé
    prototypování a zkoušení ovládání robota. Uživatel bude zadávat příkazy a
    dívat se, jak na ně robot reaguje. Tady je výhodná transparentnost
    synchronního přístupu. Naopak pro psaní kontrolních programů je větší důraz
    kladen na spolehlivost. Knihovna zajistí, že příkaz opravdu dojde, v
    nejhorším případě upozorní uživatele na skutečnost, že robot je
    neovladatelný (může se stát třeba pokud mu dochází baterie).

    Máme zde tu výhodu, že e-puck robot vždy pracuje synchronně. Na začátku
    čeká, dokud mu nedojde příkaz, pak se pustí do jeho zpracování. V tu chvíli
    ovšem přestává poslouchat Bluetooth spojení a tedy každý další zaslaný
    příkaz bude ztracen. Po zpracování příkazu robot pošle odpověď a opět začne
    čekat na příkazy z počítače. Tedy vždy platí, že robot buď zpracuje zprávy
    v takovém pořadí v jakém byly poslány, anebo případně některé z nich
    vynechá.

    Při asynchronní komunikaci tedy stačí mít frontu příkazů a kontrolovat, že
    je robot postupně vykonává. To je také důvod proč jsou zprávy opatřeny
    kódem příkazu a pořadovým číslem. Kód příkazu je jeden znak, který určuje o
    jaký příkaz se jedná (např. změna rychlosti nebo nastavení LED). Pořadové
    číslo je v podstatě také jeden znak, jeho číselná hodnota v ASCII kódování
    určuje pořadové číslo zprávy. Z toho samozřejmě vyplývá, že pořadová čísla
    nejsou unikátní. Ovšem mezi dvěma zprávami, které potenciálně mohou mít
    stejný kód i stejné pořadové číslo, musí být posláno tolik jiných zpráv, že
    pravděpodobnost záměny těchto dvou je velmi malá (musely by se ztratit
    všechny zprávy mezi nimi a v takovém případě je komunikace velmi
    nestabilní).

    Díky přidaným informacím ke zprávě není problém poslat např. více zpráv,
    které mění rychlost robota. Je zajištěno, že budou provedeny všechny
    příkazy postupně a robot skončí v očekávaném stavu. Ukázkovou situací může
    být robot, který stojí před překážkou, chceme aby se otočil a pokračoval v
    jízdě dopředu. Pokud by se ztratil první příkaz, tak robot pojede dále
    proti překážce, pokud by se ztratil druhý příkaz, tak se bude robot pouze
    točit na místě. Díky danému pořadí příkazů se nemusíme takovýchto situací
    bát.

    \section{Existující práce}

        Existuje mnoho prací, které se zabývají ovládáním robota. V sekci
        \ref{webots} bude ukázán komerční simulátor Webots. K němu vznikla také
        kniha Cyberbotics' Robot Curriculum (sekce \ref{curriculum}). Další
        kniha, která se zabývá robotikou a programovacím jazykem Python je
        Learning Computing With Robots (sekce \ref{learning-computing}). U
        Webots nekončí seznam existujících simulátorů, Evorobot* (sekce
        \ref{evorobot*}) je úzce zaměřený na evoluci a využívá k tomu e-puck
        robota. A nakonec nesmíme zapomenout na projekt Pyro (sekce
        \ref{pyro}), který slouží pro psaní vysokoúrovňových programů pro
        ovládání robota v Pythonu a obsahuje dokonce několik simulátorů.

        \subsection{Webots}
        \label{webots}

        Webots \cite{webots} je vývojové prostředí a simulátor pro programování robotů.
        Nabízí podporu nejen pro e-puck robota a umožňuje robota programovat v
        několika jazycích (C++, Java, Python).

        Napsané programy je možné spouštět a testovat v simulátoru. To je
        samozřejmě velmi výhodné pro rychlé ladění programu. Ovšem výsledek v
        simulátoru se může od skutečného chování robota velmi lišit. Při psaní
        programů je nutné myslet na to, že sensory v robotovi jsou
        nespolehlivé, jejich hodnoty bývají zatíženy chybou a tak se na ně nedá
        stoprocentně spolehnout. Webots simulátor se snaží virtuální sensory
        přiblížit realitě a tak i hodnoty, které obdrží robot v simulátoru
        neodpovídají přesně simulované realitě.

        Výhodou Webots je tedy kvalitní simulátor, pokud se ovšem podíváme na
        ovládání skutečného robota, tak tady se od mé práce v mnohém neliší.
        Webots umožňuje dva způsoby jak řídit skutečného robota, prvním je
        kompilace programu a nahrání do robota. Ta funguje pouze pokud je
        program napsán v jazyku C.

        Druhé zajímavější řešení je použít vzdálené ovládání pomocí
        Bluetooth. Zde už mohou být programy napsány v libovolném podporovaném
        jazyce. Do robota je třeba nahrát upravený firmware. Zde ovšem nemohu
        porovnávat, protože Webots šíří firmware pouze v binární podobě, nejsou
        dostupné zdrojové kódy a v dokumentaci není k nalezení přesnější
        informace. Všechny funkce jsou ovšem volány synchronně.

        Tím se dostáváme k hlavní nevýhodě Webots. Jedná se o komerční projekt,
        dostupná zdarma je pouze testovací časově omezená verze a nejsou
        dostupné zdrojové kódy (právě např. firmware).

        \subsection{Cyberbotics' Robot Curriculum}
        \label{curriculum}

        Pokud jsme se bavili o Webots, tak stojí za zmínku také kniha
        Cyberbotics' Robot Curriculum \cite{cyberbotics}. Autorem je Olivier
        Michal, dále byla rozšířena na EPFL, nyní je dostupná na
        Wikibooks \cite{wikibooks}. Kniha je určena všem, kteří mají zájem o
        robotiku. Skládá se ze dvou částí, v první pojednává o teoretických
        základech (umělá inteligence, robotika, e-puck robot), ve druhé už se
        snaží čtenáře naučit jak se ovládají roboti.

        Kniha pro výuku programování robota používá e-puck robota a simulátor
        Webots. Vysvětluje principy, které se při programování robotů
        používají. Postupuje od jednoduchých příkladů jako je pohyb s robotem,
        vyhýbání se překážkám, následování čáry, přes využití všech senzorů
        robota (akcelerometr, kamera) až ke složitějším technikám.

        V kapitole pro pokročilé čtenáře se zabývá odometrií, plánováním cesty,
        rozpoznáváním tvarů, strojovým učením a dalšími metodami vyvíjení
        kontrolního programu (genetické algoritmy, particle swarm optimization,
        \ldots).

        Tato kniha je výborným doplňkem příkladů uvedených v této práci. Může
        být zdrojem zajímavých a podnětných příkladů a experimentů.

        \subsection{Learning Computing With Robots}
        \label{learning-computing}

        Jedná se o další knihu, která se vztahuje k programování robotů.
        Learning Computing With Robots \cite{learning} ovšem není psána o e-puck
        robotovi, ale o jednoduchém robotovi Scribbler. Kniha se spíše zabývá
        výukou programování v programovacím jazyku Python a robota používá pro
        ukázku zajímavých příkladů.

        Kniha se tedy dá chápat jako úvod pro ty, kdo se chtějí naučit Python,
        aby mohli dále pokračovat ve výuce programování robotů.

        \subsection{Evorobot*}
        \label{evorobot*}

        Evorobot* je software vyvinutý pro provádění experimentů na evoluci
        kolektivního chování a komunikace, založen na e-puck robotovi. Skládá
        se z několika částí:

        \begin{itemize}
            \item Evoluční algoritmus,
            \item simulátor neuronové sítě,
            \item simulátor robota a prostředí,
            \item grafické rozhraní a příkazy pro analýzu experimentů,
            \item nástroje pro testování a vyvíjení robota a
            \item Evorobot* firmware pro nahrání do robota a následné ovládání pomocí programu z PC.
        \end{itemize}

        Evorobot* tedy slouží k vytváření neuronové sítě pro ovládání robota,
        její vyvíjení v simulovaném prostředí a následnou adaptaci a testování
        na skutečném hardware. Součástí programu je několik experimentů
        ukazujících možnosti vývoje ovládání robota.

        \subsection{Pyro}
        \label{pyro}

        Pyro je zkratka pro Python Robotics, jedná se o projekt jehož cílem je
        vytvořit prostředí pro zkoumání pokročilých témat z umělé inteligence a
        robotiky bez starostí o nízkoúrovňové problémy hardware.

        Pyro je napsán v Pythonu, každý experiment se skládá z několika částí:
        \begin{itemize}
            \item Simulátor světa,
            \item simulátor hardware robota,
            \item ovládácí program robota.
        \end{itemize}

        Simulátor funguje jako server a zpracovává celý experiment. Na výběr je
        několik simulátorů, od jednoduchého 2D, přes 3D prostředí se simulací
        fyziky, až po simulaci soutěže RoboCup. Simulátory mohou být také
        diskrétní, je tedy možné simulovat i problémy zapadající spíše do umělé
        inteligence. Pyro například obsahuje simulaci světa Wumpus \cite{aima}.

        Další součástí je simulace robota, pyro podporuje několik
        rodin robotů:

        \begin{itemize}
            \item Pioneer -- Pioneer, Pioneer2, PeopleBot robots,
            \item Khepera -- Khepera, Khepera 2 a Hemisson robots,
            \item AIBO a
            \item Roomba.
        \end{itemize}

        Nakonec nejdůležitější součástí je samotný mozek robota, jedná se o
        program napsaný v Pythonu, který robota řídí. Zde je upřednostněna
        velká míra abstrakce tak, aby stejný program mohl být testován na více
        robotech. Pyro navíc obsahuje moduly pro různé přístupy k ovládání
        robota (konečné automaty, neuronové sítě, posilované učení, fuzzy
        logika, evoluční algoritmy,~\ldots).

    \section{Specifikace e-puck knihovny}

    Účelem této práce je být výukovým materiálem, tedy je občas kladen důraz na
    vlastnosti, které by v jiné situaci byly opomíjeny.

    První důležitou vlastností je otevřenost zdrojových kódů. Uživatel je
    povzbuzován, aby do nich nahlédl. Jsou důkladně okomentovány a měly by
    čtenářům ukázat příklad, jak může komunikace s robotem probíhat. Stejně tak
    ukázkové kontrolní programy jsou určeny pro předvedení možných způsobů
    ovládání robota.

    Uživatel si může vybrat zda-li má být komunikace synchronní nebo
    asynchronní. Synchronní komunikace slouží k experimentování s robotem, ve
    spojení s Pythonem se jedná o velmi jednoduchý a rychlý způsob jak robotovi
    předávat příkazy. Jedná se o jednu z výhod e-puck knihovny.

    V případě psaní složitějších programů ovšem e-puck knihovna nezůstává v
    ničem pozadu za konkurencí. Nabízí spolehlivou asynchronní komunikaci, díky
    které se může uživatel spolehnout, že příkazy posílané robotovi budou
    opravdu provedeny. Tohoto ovšem nebylo dosaženo bez úsilí, asynchronní
    komunikace samotná není dokonalá a nedokáže vyřešit všechny problémy. Je
    nutné, aby s ní spolupracoval firmware v robotovi.

    \subsection{Firmware}

    Původní BTcom firmware funguje velmi přímočaře, jedná se o jednu nekonečnou
    smyčku, ve které načítá příkazy, zavolá příslušné funkce a odešle odpověď.
    Díky tomu, že je program takto prostý, je jednoduché provozovat synchronní
    komunikaci. Program načítá příkazy přesně tak, jak mu přijdou, jeden po
    druhém. Na každý odpoví a teprve pak se přesune na zpracování dalšího
    příkazu.

    Problém ovšem nastane pokud dojde k poruše spojení a nějaký příkaz
    nedorazí. Původní firmware nedokázal problémy tohoto typu rozpoznat. Navíc
    pokud robot pracuje v binárním režimu, tak posílá pouze data, bez
    jakéhokoli označení příslušnosti k příkazu, nebo informace o povaze dat.
    Proto bylo provedeno několik úprav, v původním stavu se totiž jednalo o
    téměř neřešitelný problém, rozpoznat ke kterému příkazu data přísluší.

    Upravený firmware obsahuje několik mechanismů pro zabezpečení spolehlivé
    komunikace. V kapitole \ref{btcom:prikazy} je popsáno jak bylo potřeba
    upravit příkazy, aby se daly svázat s patřičnou odpovědí. K příkazům např.
    přibylo pořadové číslo.

    V části \ref{btcom:upravy} jsou popsány další změny firmware. Binární
    příkazy v odpovědi posílají celou hlavičku obsahující kód příkazu, pořadové
    číslo a velikost přenášených dat. Dále firmware získal možnost upozornit na
    nízký stav baterie. Možná se způsob, jakým je toto upozornění provedeno,
    zdá podivný, protože rozsvícení LED začne baterii vybíjet ještě víc, ovšem
    ve chvíli kdy dojde k upozornění už je baterie vybitá tak, že komunikace s
    robotem je velmi problémová a složitější příkazy už stejně není schopen
    vykonat.

%}}}
\chapter{Implementace} %{{{
\label{Implementace}

    Hlavní součástí této práce je samozřejmě samotná implementace knihovny.
    Důležitou změnou je úprava firmware robota. V sekci \ref{btcom} je
    představen firmware BTcom, který je používán pro ovládání robota. Jsou zde
    také uvedeny změny, které bylo nutné provést pro zabezpečení spolehlivé
    asynchronní komunikace.

    Samotná implementace asynchronní komunikace je představena v sekci
    \ref{async-impl}. Jedná se o představení mechanismů, díky kterým je možné
    provádět komunikaci asynchronně. K asynchronní komunikaci také patří
    zpracování odpovědi a vyhodnocování ztracených příkazů.

    Nakonec je představena pro uživatele ta nejzajímavější část a to rozhraní
    pro komunikaci s robotem (sekce \ref{controller}). Jedná se o most mezi
    uživatelem a třídami, které se starají o komunikaci. Dochází zde k převodu
    příkazů do srozumitelné formy pro robota a naopak také k převádění odpovědí
    od robota do formátu čitelného pro uživatele.

    \section{BTcom firmware}
    \label{btcom}

    Robot e-puck v sobě obsahuje programovatelný mikroprocesor. Většina ze
    stávajících řešení se zaměřuje na psaní programu právě pro tento
    mikroprocesor. Ty jsou, co se výpočetního výkonu týče, velmi limitovány.
    Tato práce se však v tomto ohledu liší od ostatních. Programátor píše
    program, který běží na PC a pouze jednotlivé příkazy jsou posílány do
    robota ke zpracování.

    Je tedy potřeba, aby v robotovi byl software, který dokáže přijímat
    příkazy, zpracovávat je a odesílat odpovědi. K tomuto účelu byl upraven
    tvůrci robota poskytovaný firmware BTcom. Jedná se o jednoduchý program,
    který společně se standardní knihovnou dodávanou k e-puck robotovi
    zpřístupňuje všechny senzory a akční členy robota pomocí jednoduchého
    protokolu přes Bluetooth rozhraní.

    \subsection{Příkazy}
    \label{btcom:prikazy}

    Příkazy je možné posílat v textovém nebo binárním režimu. Textový režim
    slouží k posílání jednoduchých dat jako je ovládání led diod nebo nastavení
    rychlosti motorů. Binární režim slouží k získávání větších dat, jako jsou
    například snímky z kamery.

    Příklad jak může vypadat příkaz poslaný robotovi: {\tt
    Da,100,100\textbackslash r}. Zde se jedná o textový příkaz, první znak
    určuje typ příkazu, písmeno \uv{D} je příkaz pro změnu rychlosti kol. Druhé
    písmeno je tzv. timestamp, jedná se právě o kontrolní znak, který určuje
    pořadí příkazů a odlišuje příkazy stejného typu. Dále následují dvě čísla,
    první určuje rychlost levého kola, druhé rychlost pravého kola. Nakonec je
    znak řádku, který určuje konec příkazu.

    Binární příkazy se také rozlišují písmenem, avšak aby bylo rozpoznání
    zjednodušeno (přesněji řečeno, aby stačilo jedno porovnání), tak kód pro
    binární příkazy je záporný. Firmware přečte kód příkazu jako 8--bitové
    číslo se znaménkem. Pokud je záporné, tak automaticky předpokládá, že vše
    co následuje je binární příkaz. Protože data v příkazu nejsou nijak
    kódována, tak není např. možné předpokládat, že se v příkazu neobjeví číslo
    10, které v ASCII tabulce reprezentuje znak konce řádku. Z toho důvodu jsou
    příkazy ukončeny bytem 0.

    Odpovědi v binárním režimu začínají hlavičkou, která obsahuje identifikaci
    a velikost následující odpovědi. Díky tomu nemusí být nějak speciálně
    ukončovány.

    Hlavní výhodou binárního režimu tedy je úspora dat při přenosu a možnost
    vyhnout se kódování odpovědi a posílat ji jako surová data.

    \subsection{Provedené úpravy}
    \label{btcom:upravy}

    Provedené úpravy se snaží vyřešit problémy stávajícího řešení a také
    umožňují použití asynchronní komunikace. Ke každému příkazu poslanému
    robotovi se přidává časový otisk, jedná se o 8--bitové číslo, které určuje
    pořadí příkazu v sérii. Ve své odpovědi pak robot uvede jak kód označující
    typ příkazu, na který odpovídá, tak také došlý otisk. Díky tomu je možné
    téměř jednoznačně (otisk se samozřejmě opakuje po určité době znova) svázat
    odpoveď se zaslaným příkazem. Pokud tedy nějaké číslo chybí v posloupnosti
    přijatých odpovědí, je jasné, že tato odpověď nedorazila.

    Odpovědi na binární příkazy nyní vždy obsahují hlavičku, která je pro
    všechny stejná a obsahuje samozřejmě kód příkazu, na který odpovídá, a také
    jeho timestamp, ale hlavně obsahuje i velikost dat, která budou následovat.
    Při binární komunikaci totiž není možné rozpoznat konec přenosu dat. V
    původní verzi firmware se počítalo s tím, že po každém odeslaném příkazu
    bude uživatel čekat na jeho odpověď a tedy bude vědět jakého formátu jsou
    data, která očekává. Pokud se ovšem snažíme o asynchronní komunikaci, tak
    bychom neměli o příchozích datech nic předpokládat.

    Do firmware byly také přidány nové příkazy. Robot obsahuje 3 mikrofony, ale
    není jednoduché nasnímaná data odeslat do PC kvůli jejich velikosti. Pro
    programy, které jsou spouštěny přímo v robotovi, ovšem existuje knihovna
    pro FFT (rychlou Fourierovu transformaci). Ta byla byla přidána do BTcom
    firmwaru a díky ní je možné jedním příkazem zapnout snímání dat z mikrofonu
    a druhým příkazem na nasnímaných datech provést transformaci a odeslat je
    do PC.

    Dalším problémem, se kterým se musí uživatel e-puck robota potýkat, je
    kapacita baterie a nepřítomnost jakéhokoli ukazatele jejího stavu. Tento
    problém byl alespoň částečně vyřešen, do kontrolního programu v robotovi
    bylo přidáno přerušení, které je aktivováno právě tehdy, když napětí na
    baterii již není dostatečné pro bezproblémový provoz. Při vyvolání tohoto
    přerušení jsou zapnuty všechny LED na obvodu robota a tak uživatel dostane
    vizuální upozornění, že je třeba baterii vyměnit.

    \section{Synchronní komunikace}

    Hlavním cílem synchronní komunikace je umožnit uživateli knihovny
    jednoduché zasílání příkazů, u kterého není kladen důraz na ošetření
    výjimek. Počítá se s tím, že uživatel bude využívat synchronní komunikaci
    pro experimentování s robotem a prototypování příkazů.

    Hlavní výhodou synchronní komunikace je její jednoduchost. Jak lze vidět
    ve zdrojovém kódu \ref{lst:sync_example}, příkaz lze předat robotovi
    zavoláním pouze jedné metody, která navíc i vrátí odpověď od robota. V
    tomto případě se jedná o rychlost motorů. Díky tomu lze robota ovládat i z
    interpretu Pythonu, čímž se výrazně zkrátí doba potřebná pro testování
    nových nápadů. Tam kde je normálně potřeba napsat zdrojový kód, zkompilovat
    aplikaci a následně ji pustit, tady stačí pouze pustit Python, importovat
    knihovnu, vytvořit spojení (což jsou 2 řádky kódu) a pak už nám nic nebrání
    v posílání příkazů.

    Každé zavolání příkazu odešle robotovi zprávu (bližší popis zprávy v části
    \ref{btcom:prikazy}) a následně zablokuje (zavoláním metody {\tt read} na
    sériové spojení) další vykonávání příkazů, dokud neobdrží odpověď.

    \begin{listing}[h]
    \begin{pyc}
>>> from epuck import Controller
>>> controller = Controller('/dev/rfcomm0')
>>> controller.get_speed()
(0,0)
    \end{pyc}
    \caption{Příklad synchronní komunikace}
    \label{lst:sync_example}
    \end{listing}

    \section{Asynchronní komunikace}
    \label{async-impl}

    Asynchronní komunikace se snaží co nejvíce usnadnit ovládání robota, skrýt
    některé složitější mechanismy komunikace před uživatelem a přitom zajistit
    spolehlivou komunikaci. Krátká ukázka asynchronní komunikace je ve
    zdrojovém kódu \ref{lst:async_example}.

    \begin{listing}[h]
    \begin{pyc}
>>> from epuck import Controller
>>> controller = Controller('/dev/rfcomm0', asynchronous=True)
>>> request = controller.get_speed()
>>> request.get_response()
(0,0)
    \end{pyc}
    \caption{Příklad asynchronní komunikace}
    \label{lst:async_example}
    \end{listing}

    Základním požadavkem asynchronní komunikace je oddělení zavolání příkazu od
    jeho provedení. Provedení totiž může trvat delší dobu a to se může ukázat v
    některých aplikacích jako klíčový problém. Příkazy tedy nečekají na
    odpověď, ovšem jak se pak uživatel dostane k odpovědi? Zavolání příkazu
    nemůže vrátit odpověď, ale na druhou stranu může vrátit uživateli odkaz na
    potenciální odpověď. Toho se pak může dotázat, zda-li odpověď přišla a
    nakonec ji také i získat. Ukázka je ve zdrojovém kódu
    \ref{lst:async_example}. Pro vysvětlení jak tento odkaz funguje bude
    potřeba osvětlit vnitřnosti asynchronní komunikace.

    Asynchronní komunikace už od připojení robota probíhá v samostatném vláknu,
    které je nezávislé od vlákna, ve kterém běží program uživatele. Toto
    komunikační vlákno zastává tři funkce:

    \begin{enumerate}
        \item Odesílání příkazů
        \item Zpracování příchozí komunikace
        \item Kontrola chyb
    \end{enumerate}

    Příchozí komunikace je získávána pomocí sériového připojení vytvořeného
    knihovnou pySerial. Připojení podporuje standardní metody pro práci se
    sockety a je tedy možné používat funkci select operačního systému, která
    dokáže kontrolovat více připojení a oznámit přijetí dat na libovolném z
    nich. První připojení, které je kontrolováno, tedy je sériové připojení s
    robotem. Další spojení slouží k získávání nových příkazů.

    \subsection{Odeslání příkazu}

    Při odesílání příkazů se vlastně jedná o přenesení informace v reálném čase
    z jednoho vlákna do druhého. Příkaz je zavolán ve vláknu s uživatelským
    programem, ovšem samotná zpráva robotovi musí být odeslána z vlákna
    asynchronní komunikace. V opačném případě by uživatelský program byl
    zpomalen přenosem k robotovi, navíc asynchronní vlákno má větší přehled o
    spojení s robotem a tedy např. nedojde ke kolizi mezi posíláním a
    přijímáním dat.

    V uživatelském vláknu je příkaz zařazen do fronty pro odchozí příkazy,
    asynchronní vlákno je pak následovně informováno o novém příkazu, nakonec
    je vytvořen odkaz na příkaz, který je vrácen uživateli. Žádný z těchto
    příkazů není blokující, tedy odeslání příkazu nestojí uživatele téměř nic.

    \begin{listing}[H]
    \begin{pyc}
# Zaslani prikazu
request = controller.get_speed()
# Kontrola, zda-li uz prisla odpoved
while not request.response_received():
    # Program zde muze delat cokoli jineho,
    # zatimco ceka na odpoved
# Ziskani odpovedi
value = request.get_response()


    \end{pyc}
    \caption{Ukázka oddělení zaslání příkazu a vyzvednutí odpovědi}
    \end{listing}

    Zbytek odeslání příkazu už probíhá v asynchronním vláknu. Funkce select je
    přerušena informací o novém příkazu. Následně je příkaz odebrán z fronty,
    odeslán robotovi a zařazen do fronty odeslaných zpráv. Zde čeká na příchozí
    odpověď. Uživatel stále vlastní odkaz na tento příkaz, i když se přesunul.

    \subsection{Zpracování odpovědi}

    Pokud se robot rozhodne odeslat odpověď na příkaz, tak se to asynchronní
    vlákno dozví díky funkci select, která označí spojení, které je připraveno
    pro čtení. Následuje tedy přečtení a zpracování odpovědi. Nejprve je
    potřeba rozhodnout, zda-li se jedná o binární nebo textovou odpověď. Na to
    stačí přečíst první znak, ten určuje na který příkaz robot odpovídá. Další
    znak určí timestamp, díky němu už je možné jednoznačně najít příkaz ve
    frontě odeslaných, kterému odpověď patří.

    Odpověď pak už je pouze předána příkazu, který si ji uloží. Příkaz je
    následně odebrán z fronty odeslaných příkazů. Pokud si uživatel uložil
    odkaz na tento příkaz, tak stále má možnost získat odpověď. V opačném
    případě už na objekt nic neukazuje a tedy bude smazán.

    \subsection{Časový limit}

    Může se stát, že příkaz k robotovi nedorazí. Tato skutečnost se těžko
    rozpoznává. Robotovi zabírá vykonání příkazu delší dobu, anebo o příkazu
    vůbec neví? Kdy už se má příkaz považovat za ztracený? Pro vyřešení těchto
    problémů slouží časový limit. Pro každý příkaz má robot přidělen časový
    limit v kterém musí odpovědět. Časový limit je vždy dán funkci select,
    která vlákno zablokuje právě na tuto dobu. Následně dojde ke kontrole
    příkazů. Každý příkaz, který už je ve frontě příliš dlouho, je označen za
    ztracený a poslán znova.

    \section{Ovládání robota}
    \label{controller}

    Pokud je zajištěna komunikace s robotem, tak samotné jeho ovládání už je
    velmi jednoduché. Při vytváření ovladače robota musí uživatel specifikovat,
    zda-li chce komunikaci synchronní anebo asynchronní. Hlavní změna, kterou
    pozná, je v návratové hodnotě příkazů. Při synchronní komunikaci příkazy
    vrací rovnou výsledek, při asynchronní dostane nejprve odkaz na příkaz. Z
    toho důvodu není možné psát programy, které budou fungovat se synchronní i
    asynchronní komunikací.

    Zaslání příkazu je pouhé zavolání funkce a předání správných parametrů.
    Ovladač se sám stará o vytvoření příkazu, přidá k němu timestamp, zakóduje
    parametry a předá k odeslání.

    Stejně tak ovladač zpracovává příchozí odpovědi, než vydá uživateli
    výsledek. U jednoduchých příkazů, jako je třeba nastavení rychlosti motorů,
    jde pouze o získání dvou čísel z řetězce. U složitějších příkazů už se může
    jednat o netriviální činnost, například při získání fotky je potřeba
    převést fotku z formátu, který používá robot, do formátu standardní
    knihovny Pythonu.

%}}}
\chapter{Uživatelská dokumentace} %{{{

    \section{Připojení robota}
    \label{pripojeni_robota}

    Pro využívání knihovny je nutné mít robota připojeného k PC. Robot se chová
    jako standardní Bluetooth zařízení. Poskytuje pouze jedinou službu a to
    sériovou komunikaci. Je tedy potřeba nakonfigurovat sériový port, přes
    který bude knihovna s robotem komunikovat.

    \subsection{Příprava}

    E-puck robot s počítačem komunikuje pomocí Bluetooth. Pro připojení robota
    k počítači na operačním systému Linux je tedy třeba mít nainstalovánu
    podporu pro Bluetooth. Většinou jsou to balíčky {\tt bluez-firmware} a {\tt
    bluez-utils}, dále je potřeba mít software pro správu pin ({\tt bluez-pin,
    bluez-gnome a bluetooth-applet, \ldots}).

    Nejprve je potřeba zjistit adresu robota. Lze využít utilitu {\tt hcitool}:

    \begin{verbatim}                .
    $ hcitool scan
    \end{verbatim}

    Adresa robota se použije při nastavení virtuálního sériového portu v
    souboru {\tt /etc/bluetooth/rfcomm.conf}:

    \begin{verbatim}
    rfcomm0 {
        bind yes;
        device 08:00:17:2C:E0:88; # Adresa zařízení
        channel 1;
        comment "e-puck_0006";    # Vlastní komentář
    }
    \end{verbatim}

    Tím jsme nakonfigurovali zařízení {\tt /dev/rfcomm0}.

    \subsection{Přípojení}

    Zařízení reprezentující spojení s robotem jsme nakonfigurovali, nyní zbývá
    připojit robota:

    \begin{verbatim}
    $ rfcomm connect rfcomm0
    \end{verbatim}

    Po těchto příkazech by už mělo být vytvořené spojení s robotem a je možné
    mu začít posílat příkazy pomocí knihovny. V průběhu připojení se systém
    může dotázat na PIN, který je potřeba pro spárování zařízení pomocí
    Bluetooth.

    \subsection{Přehled možných chyb}
    Při připojení se můžou vyskytnou chyby, nejčastější jsou tyto:
    \begin{itemize}
    \item{{\em Can't connect RFCOMM socket: Connection refused} -- Nejspíše
        neběží žádná aplikace, která by se na heslo zeptala. Je třeba spustit
        např. {\tt bluetooth-applet}.}
    \item{{\em Can't create RFCOMM TTY: Address already in use} -- Možná
        příčína je už připojené zařízení. Buď už běží {\tt rfcomm}, anebo jiná
        aplikace, která s robotem udržuje komunikaci. Řešením je zavřít
        aplikace komunikující s robotem, popř. zkusit následující příkazy:
    \begin{verbatim}
    $ rfcomm release rfcomm0
    $ rfcomm connect rfcomm0
    \end{verbatim}
    }
    \end{itemize}

    \section{Ukázkový program}

    Pro ovládání robota slouží modul {\tt epuck} a objekt {\tt Controller}.
    Ovládání robota je velmi jednoduché. Ukážeme si program pro pohyb robota
    dopředu, dokud nenarazí na překážku a na něm rozebereme jednotlivé příkazy:

    %\begin{listing}[H]
        \begin{pyc}
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""Go forward, stop in front of an obstacle."""

import time

from epuck import Controller

# Input larger than the threshold means there is an obstacle.
threshold = 300

# Create the controller. Robot is connected to /dev/rfcomm2
# and the communication will be asynchronous.
controller = Controller('/dev/rfcomm2', asynchronous=True)

# Set the speed of left and right wheel to 100.
controller.set_speed(100, 100)

# Ask for the values of proximity sensors
sensor_request = controller.get_proximity_sensors()
# Wait until the robot returns them.
sensor_values = sensor_request.get_response()

# Continue while there is nothing in front of the front left
# and front right sensor.
while (sensor_values['L10'] < threshold) \
       and (sensor_values['R10'] < threshold):
    # Wait for a while
    time.sleep(0.1)
    # Read new values
    sensor_request = controller.get_proximity_sensors()
    sensor_values = sensor_request.get_response()

# Stop the robot
controller.set_speed(0, 0)
        \end{pyc}
    %\caption{Jednoduchý asynchronní program pro ovládání robota}
    %\label{lst:simple_example}
    %\end{listing}

    Tento kód tvoří celý program pro ovládání robota. První věcí, kterou je
    třeba vždy učinit, je import knihovny:

    \begin{pyc*}{firstnumber=8, frame=none}
from epuck import Controller
    \end{pyc*}

    Nyní máme importovanou třídu {\tt Controller}, která slouží ke komunikaci s
    robotem. Stačí už jen vytvořit samotné spojení:

    \begin{pyc*}{firstnumber=15, frame=none}
controller = Controller('/dev/rfcomm2', asynchronous=True)
    \end{pyc*}

    Vytvoření spojení je jednoduché, první parametr je cesta k připojenému
    robotovi (jak připojit robota je popsáno v kapitole
    \ref{pripojeni_robota}). Druhý parametr je nepovinný a určuje, zda-li má
    komunikace probíhat asynchronně. V tomto případě chceme asynchronní
    komunikaci, pokud bychom druhý parametr vynechali, tak by komunikace byla
    synchronní.

    Nyní už můžeme zadávat příkazy:

    \begin{pyc*}{firstnumber=18, frame=none}
controller.set_speed(100, 100)
    \end{pyc*}

    Zde nastavíme rychlost robota na 100 tiků za sekundu. V tomto případě nám
    stačí pouze vykonat příkaz a nepotřebujeme získat odpověď od robota. V
    případě změny rychlosti robot pouze pošle potvrzení, protože používáme
    asynchronní komunikaci, toto potvrzení bude zpracováno automaticky.

    Pokud ovšem chceme i odpověď, tak se příkaz skládá ze dvou kroků:

    \begin{pyc*}{firstnumber=20, frame=none}
# Ask for the values of proximity sensors
sensor_request = controller.get_proximity_sensors()
# Wait until the robot returns them.
sensor_values = sensor_request.get_response()
    \end{pyc*}

    Nejprve pošleme příkaz a uložíme si návratovou hodnotu. Ta reprezentuje
    odpověď, která přijde na zaslaný příkaz. Druhým krokem pak je získání této
    odpovědi.

    Když už jsme získali nějaké data od robota, tak je můžeme zpracovat (v
    tomto případě to jsou hodnoty z IR senzorů):

    \begin{pyc*}{firstnumber=27, frame=none}
while (sensor_values['L10'] < threshold) \
       and (sensor_values['R10'] < threshold):
    \end{pyc*}

    Kontrolujeme zde, zda-li  před robotem nic není. Bižší popis je v
    dokumentaci metod. V případě, že před robotem nic není můžeme program na
    chvíli uspat, zatím se robot posune o kus dál a my můžeme znova
    zkontrolovat senzory:

    \begin{pyc*}{firstnumber=29, frame=none}
    # Wait for a while
    time.sleep(0.1)
    # Read new values
    sensor_request = controller.get_proximity_sensors()
    sensor_values = sensor_request.get_response()
    \end{pyc*}

    Vzhledem k tomu, že kontrola probíhá v nekonečné smyčce tak krátká pauza
    slouží k nevytěžování procesoru PC na 100\%.

    Pokud narazí robot na překážku, tak jediné, co mu zbývá před zastavením, je
    zastavit motory:

    \begin{pyc*}{firstnumber=36, frame=none}
    controller.set_speed(0, 0)
    \end{pyc*}

%}}}
\chapter{Příklady kontrolních programů} %{{{

%}}}
\chapter{Závěr} %{{{

    \section{Zhodnocení práce}

    \section{Benchmark knihovny}

%}}}
%{{{ Seznam literatury
%%%
%%% Literatura se řadí abecedně. Úvádí se pouze literatura, na kterou se v textu odkazuje.
%%% Při odkazu na knihu se vždy uvádějí čísla stránek.

\bibliographystyle{czechiso}
\bibliography{literatura}

%}}}
\end{document}
